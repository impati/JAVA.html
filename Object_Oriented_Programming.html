<!doctype html>
<html>
<head>
  <title>Object_Oriented_Programming</title>
  <meta charset="utf-8">
  <link rel="stylesheet" href="background.css">
<script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js?skin=선택한 스타일 이름"></script>
</head>
<body>
<div class ="main">
    <div class="left">
    </div>
    <div class="median">

      <div class="upper">

        </div>
        <div class="content">
        <h1>객체지향프로그래밍</h1>
        <div>
        <ul>

          <li><h2>객체지향</h2></li>
          <ul><li><h3>프로그램을 수 많은 객체라는 기본단위로 나누고 다루는 설계방법</h3></li></ul>
          <li><h2>객체</h2></li>
          <ul><li><h3>속성(변수)과 기능(메소드)을 갖는 집합.그러한 기능과 속성을 가지고 메모리에 생성되고 존재하는 것</h3></li></ul>
          <li><h2>클래스</h2></li>
          <ul><li><h3>서로 관련이 있는 변수와 메소드를 묶어놓은 것. 또는 객체를 정의해놓은 것</h3></li>
          <li><h3>객체를 생성하는데 쓰인다.</h3></li>
          <li><h3>데이터와 함수의 결합</h3></li>
          </ul>
          <li><h2>인스턴스</h2></li>
          <ul><li><h3>클래스로 객체를 만드는 과정이 인스턴스화 과정이며 클래스로 부터 만들어진 객체를 인스턴스라고한다.</h3></li>
          <li><h3>객체는 이러한 인스턴스들을 모두 포괄하는 의미를 갖는다</h3></li>
          </ul>
          <li><h2>인스턴스의 생성</h2></li>
          <ul><li><h3>참조형 변수를 이용하여 인스턴스를 생성하고 사용한다.</h3></li></ul>
          <pre class ="prettyprint"><code>
class person{
  	int age,cm,kg;
  	//나이 ,키,몸무게
  }
  public class Main {
      public static void main(String[] args)  {
      	//클래스 명 변수명 = new 클래스명();
      	person p = new person();
      	//p는 참조형 변수
      	//p를 이용하여 인스턴스에 생성한다.
      	//인스턴스는 이러한 참조변수가 반드시 필요하며 타입이 일치하여야 한다.

      	p.age=20;
      	p.cm=175;
      	p.kg=70;
      	System.out.println(p.age+" "+p.cm+" "+p.kg);
      	//출력 결과
      	//20 170 60
      }
  }
</code></pre>
<br>  <br>  <br>  <br>
        <li><h2>객체 배열</h2></li>
        <ul><li><h3>참조형 변수를 배열로 선언한 다음 인스턴스를 생성해준다.</h3></li></ul>
        <pre class ="prettyprint"><code>
   class person{
         int age,cm,kg;
         //나이 ,키,몸무게
    }
   public class Main {
         public static void main(String[] args)  {
              	//참조형 변수를 배열로 선언.
              	person []p = new person[10];
              	for(int i=0;i<<span>10;i++) {
                      //i번째 인스턴스 생성.
                      p[i] =  new person();

                      //적당한 값으로 초기화.
                      p[i].age =i+20;
                      p[i].cm  =160+i;
                      p[i].kg  =50+i;

              	}
              	for(int i=0;i<<span>10;i++) {
              		System.out.println(p[i].age+" "+p[i].cm+" "+p[i].kg);
              	}
              	//출력결과
              	/*
                20 160 50
                21 161 51
                22 162 52
                23 163 53
                24 164 54
                25 165 55
                26 166 56
                27 167 57
                28 168 58
                29 169 59
              	 */
              }
          }
</code></pre>
<br>  <br>  <br>  <br>
      <li><h2>변수</h2></li>

      <ol>
        <p><h3><li>인스턴스 변수</li></h3></p>
        <p>:클래스의 인스턴스를 생성할 때 만들어진다.</p><p>:인스턴스는 독립적인 메모리공간을 가지므로 인스턴스 변수는 서로 다른 값을 가질 수 있다.</p>
        <p><h3><li>클래스 변수</li></h3></p>
        <p>:static 키워드로 선언</p><p>:클래스 변수는 모든 인스턴스들이 공유할 수 있는 변수이다.</p>
        <p>:인스턴스 변수와는 달리 인스턴스를 생성하지 않고도 사용할 수 있으며 단 한번만 생성되고 소멸된다.</p>
        <p>:사용하는 방법은 클래스.클래스변수이다.</p>
        <p><h3><li>지역 변수</li></h3></p>
        <p>클래스 메서드 내에 생성되고 클래스 메서드 내에서 소멸되는 변수. {}을 벗어나면 소멸되는 특징을 갖는다.</p>
      </ol>
<br>  <br>  <br>  <br>
      <li><h2>메서드</h2></li>
      <ol>
        <p><h3><li>메서드란 ?</li></h3></p>
      <p>:특정 기능을 수행하는 코드들의 집합.</p>
      <p>:재사용성이 높으며 프로그램을 구조화 할 수 있다.</p>
      <p>:클래스 내부에 선언</p>
        <p><h3><li>메서드 선언부</li></h3></p>
        <p>:반환타입 메서드이름 (매개변수)</p>
        <pre class="prettyprint"><code>
//반환타입 메서드이름 (매개변수);
    int sum(int a,int b)
//반환타입 메서드 이름() 매개변수,인자가 없을 수도 있다.
    void print()
//반환타입 메세드 이름(매개변수)
    double calculation(double a,double b)
        </code></pre>
        <p><h3><li>메서드 구현부</li></h3></p>
        <p>:특정 기능을 수행할 코드</p>
        <pre class="prettyprint"><code>
    int sum(int a,int b) {
        return a+b;//반환 값 //구현부
    }
    void print() {
        System.out.println("impait");//구현부
    }
    double calculation(double a,double b) {
        return a*b;//반환값이 반환타입과 일치해야한다.//구현부
    }
        </code></pre>
        <p><h3><li>기본형 매개변수</li></h3></p>
        <p>:매개변수를 기본형으로 선언시 값만을 전달한다</p>
        <p>:메서드 외부에서 전달한 변수에 대해서 메서드 내부에서는 접근하지못한다.</p>
        <p>:기본 자료형,String에 해당</p>
        <p><h3><li>참조형 매개변수</li></h3></p>
        <p>:매개변수를 참조형으로 선언시 주소를 전달한다</p>
        <p>:메서드 외부에서 전달한 변수에 대해서 접근할 수 있다 따라서 값을 변경할 수 있다.</p>
        <p>:배열,인스턴스에 해당</p>

        <p><h3><li>클래스 메서드</li></h3></p>
        <p>:static 키워드로 선언하는 메서드</p>
        <p>:인스턴스나 인스턴스 메서드를 사용하지 않는 메서드를 클래스 메서드로 정의한다.</p>
        <p>:모든 인스턴스가 공동으로 사용하는 메서드를 클래스 메서드로 선언한다.</p>
        <p>:인스턴스를 생성하지 않아도 호출할 수 있다.</p>
        <p>:클래스 메서드는 인스턴스 변수,인스턴스 메서드를 사용할 수 없다.</p>

        <p><h3><li>인스턴스 메서드</li></h3></p>
        <p>:인스턴스 변수와 관련된 작업을 하는 메서드</p>
        <p>:인스턴스를 생성해야 호출 및 사용할 수 있다.</p>
    </ol>
<br>  <br>  <br>  <br>
        <h2><li>오버로딩</li></h2>

        <p>:함수의 매개변수의 개수나 타입이 다르면 함수의 이름이 같아도 다른 함수로 취급한다.</p>
        <p>:다른 상황에서 같은 기능을 하는 메서드들을 같은 이름으로 설정할 수 있다는 장점이 있다</p>
        <pre class="prettyprint"><code>
 public class Main {

	public static void main(String[] args) {
		int var1=1,var2=2;
		double var3=3.5,var4=6.5;
		long var5=99999999999L;
		long var6=88888888888L;
		long var7=108888888888L;
		System.out.println(max(var1,var2));//2
		System.out.println(max(var3,var4));//6.5
		System.out.println(max(var5,var6,var7));//108888888888


	}
	//max라는 함수가 오버로딩으로 구별되어 정상적인 컴파일이된다.
	static int max(int a,int b) {return a>b?a:b;}
	static double max(double a,double b) {return a>b?a:b;}
	static long max(long a,long b,long c){
		if(a>b) {
			if(c>a)return c;
			else return a;
		}
		else {
			if(c>b)return c;
			else return b;
		}

	}
}
        </code></pre>
        <br>  <br>  <br>  <br>
          <h2><li>가변인자</li></h2>
          <p>:함수의 매개변수가 정적이지 않고 동적으로 지정할 수 있는 기능.</p>
          <p>:타입...변수명으로 설정.</p>
          <p>:매개변수 중에서 가장 마지막에 선언해주어야 한다.</p>
          <p>:가변인자를 사용한 메서드는 오버로딩하지 않는다.</p>
          <pre class ="prettyprint"><code>
 public class Main {

        public static void main(String[] args) {

       		System.out.println(sum(1,2,3,4,5));//15
       		System.out.println(sum(1,2,3,4,5,6));//21

       	}
	static int sum(int ...arr) {
		int ret=0;
		for(int nxt: arr) {
			ret+=nxt;

		}
		return ret;
	}

}
          </code></pre>
          <br>  <br>  <br>  <br>
          <h2><li>생성자</li></h2>
          <p>:인스턴스가 생성될 때 호출되는 인스턴스 초기화 메서드</p>
          <p>:인스턴스 변수 초기화 작업을 생성자에서 한다.</p>
          <p>:생성자이름은 클래스이름과 동일해야한다.</p>
          <pre class ="prettyprint"><code>
  class myclass{
	int var;//인스턴스 변수
	//생성자 역시 오버로딩이 가능하다.
	//매개변수가 없는 생성자
	myclass(){
		var = 10;
	}
	//매개변수가 있는 생성자.
	myclass(int value){
		var=value;
	}
	//생성자를 통한 인스턴스 복사.
	myclass(myclass s3){
	    var = s3.var;
	}
 }
 public class jp {

	public static void main(String[] args) {

		myclass s1 = new myclass();
		myclass s2 = new myclass(20);
		myclass s3 = new myclass(s2);
		System.out.println(s1.var);//10
		System.out.println(s2.var);//20
		System.out.println(s3.var);//20

	}

 }
          </code></pre>
          <p>:this()생성자: 같은 클래스의 다른 생성자를 호출할 때 사용한다.</p>
          <p>:this:인스턴스 자신을 가르키는 참조변수. 인스턴스변수를 구별해야할 때 사용한다.</p>
          <br>  <br>  <br>  <br>
          <h2><li>초기화</li></h2>
          <ul><p><li>명시적 초기화</li></p>
            <p>:변수 선언과 동시에 초기화</p>
            <p><li>초기화 블럭</li></p>
            <p>*인스턴스 초기화 블럭:인스턴스 변수를 초기화 하는 블럭.{초기화}</p>
            <p>*클래스 초기화 블럭:클래스 변수를 초기화 하는 블럭 클래스 생성시 단 한번 호출된다.static{초기화}</p>
            <li>초기화 순서</li>
            :기본값 -> 명시적 초기화 -> 초기화 블럭 ->생성자를 통한 초기화
        </ul>
        <pre class ="prettyprint"><code>
 class myclass{
	int var=5;//명시적 초기화
	static int total=5;//명시적 초기화
	static { total =10;/*클래스 초기화 블럭*/}
	{ var =10; /*인스턴스 초기화 블럭*/}

	myclass(int value){//생성자를 통한 초기화
		var =value;
	}


 }

        </code></pre>
      </ul>
        <br>  <br>  <br>  <br>
      </div>
        </div>
        <div class="bound">
        </div>


    </div>
    <div class ="right">
    </div>
  </div>
</body>

</html>
