<!doctype html>
<html>
<head>
  <title>Object_Oriented_Programming Ⅱ</title>
  <meta charset ="utf-8">
  <link rel="stylesheet" href="background.css">
  <script src="https://cdn.rawgit.com/google/code-prettify/master/loader/run_prettify.js?skin=선택한 스타일 이름"></script>
  </head>
<body>
<div class ="main">
  <div class ="left">
    </div>
  <div class ="median">
    <div class ="upper">
      </div>
    <div class ="content">
      <h1>객체지향프로그래밍 Ⅱ</h1>
      <div>
      <ul>
        <li><h2>상속</h2></li>
        <ul>
        <li><p>기존의 클래스를 이용하여 새로운 클래스를 만드는 것</p></li>
        <li><p>extends 키워드를 통해 상속 받는다.</p></li>
        <li><p>상속해주는 클래스를 <span style ="color:red" >조상,부모,기반클래스</span>라고한다</p></li>
        <li><p>상속받는 클래스를<span style ="color:red">자식,하위 클래스</span>라고한다</p></li>
        <li><p>상속받은 클래스는 부모클래스의 멤버들을 모두 가지고있다.</p></li>
      </ul>
        <pre class ="prettyprint"><code>
 class Parent_class{
	 int v1,v2,v3;
	 Parent_class(){
		 v1=1;v2=2;v3=3;
	 }
 }
 class Child_class extends Parent_class{
	 int v4,v5;
	 Child_class(){
		 v4=4;v5=5;
	 }
 }
 public class Main {

	 public static void main(String[] args) {
		 Child_class s = new  Child_class();
		 //자식 클래스 인스턴스에서 상속받은 부모클래스 멤버를 가지고 있는것을 볼 수 있다.
		 System.out.println(s.v1);//1
		 System.out.println(s.v2);//2
		 System.out.println(s.v3);//3
		 System.out.println(s.v4);//4
		 System.out.println(s.v5);//5
	 }
 }

        </code></pre>
        <h2><li>오버라이딩</li></h2><ul>
        <li><p>부모 클래스로부터 상속받은 메서드의 내용을 수정하여 사용하는 것을 오버라이딩이라고 한다.</p></li>
        <li><p>오버라이딩은 부모 클래스의 메서드와 이름,매개변수,반환타입 <span style="color:red">모두 일치</span>해야한다.</p></li>
        <li><p>부모 클래스의 메서드보다 좁은 접근 제어자를 지정할 수 있지만 더 많은 수의 예외를 둘 수 없다.</p></li></ul>
          <pre class ="prettyprint"><code>
 class Parent_class{
  	void print() {
 		 System.out.println("Parent_class");
	 }
 }
 class Child_class extends Parent_class{
	 //상속받은 print메서드를 오버라이딩
	 void print() {
		 System.out.println("Child_class");
	 }
 }
 public class Main {

	 public static void main(String[] args) {
		 Child_class s = new  Child_class();

		 s.print();//Child_class
	 }
 }

          </code></pre>
          <h2><li>super 와 super()</li></h2>
          <ol>
            <li><h3>super</h3></li>

            <p>super키워드는 부모 클래스의 멤버를 참조하는데 사용되는 참조변수</p>
            <p>같은 이름으로 정의한 변수나 메서드에 대해 super키워드로 구별하여 사용할 수 있다.</p>
            <li><h3>super()</h3></li>
            <p>부모 클래스이 생성자를 호출하는데 사용된다</p>
            <p>상속 받은 자손 클래스에서 이러한 부모클래스를 호출하지않으면 컴파일러가 자동으로 super()를 호출한다</p>
            <p>자손 클래스는 부모클래스의 생성자를 호출할 의무가 있다.</p>

              <pre class ="prettyprint"><code>
   class Parent_class{
	 int v1,v2,v3;
	 Parent_class(){
		 v1=1;v2=2;v3=3;
	 }
	 Parent_class(int a,int b,int c){
		 v1=a;v2=b;v3=c;
	 }
 }
 class Child_class extends Parent_class{
	 int w1,w2,w3;
	 int v1,v2,v3;
	 Child_class(){
		 super(10,100,1000);//부모 생성자 호출
		 v1=-10;v2=-100;v3=-1000;
	 }
	 void print() {
		 System.out.println(this.v1);
		 System.out.println(this.v2);
		 System.out.println(this.v3);
		 System.out.println(super.v1);
		 System.out.println(super.v2);
		 System.out.println(super.v3);
	 }
 }
 public class jp {

	 public static void main(String[] args) {
		 Child_class s = new  Child_class();
		 s.print();
                  /*
                  출력결과
                  -10
                  -100
                  -1000
                  10
                  100
                  1000
                  */
	 }
 }

              </code></pre>
          </ol>





          <li><h2>제어자</h2></li>
          <ul><li>제어자란 클래스,변수,메서드의 선언부에 함께 사용되어 부가적인 의미를 부여한다</li>
          <li>하나의 대상에 대해서 여러 제어자를 조합하여 사용할 수 있다.</li></ul>
          <ol>
            <li><h3>staic</h3></li>
            <ul><li><p>클래스의 공유변수,공유 메서드로써 static키워드로 선언시 인스턴스 생성없이도 호출가능.</p></li></ul>
            <li><h3>final</h3></li>
            <ul><li>변경될 수 없는 의미를 가지고 있다.변수에 사용되면 상수가 된다.</li>
              <li><p>메서드에 사용되면 오버라이딩할 수 없다</p></li>
              <li><p>클래스에 사용되면  자손클래스를 정의할 수 없다.</p></li>
            </ul>
            <li><h3>abstract</h3></li>
            <ul><li><p>메서드의 선언부만 작성하고 실제 내용은 구현하지 않는 추상메서드를 선언하는데 사용한다</p></li>
              <li><p>클래스에 abstract 제어자가 있으면 인스턴스를 생성할 수 없다. </p></li>
            </ul>
            <li><h3>access modifier</h3></li>
            <ul>
            <li><p>클래스의 멤버 또는 클래스에 사용되며 외부에서 접근하지 못하도록 하는 역할을 한다.</p></li>
            <li><p>public:접근제한이 없다</p></li>
            <li><p>protected:같은 패키지 내에서 또는 다른 패키지의 자손클래스에서 접근이 가능하다</p></li>
            <li><p>default:같은 패키지 내에서 접근이 가능하다</p></li>
            <li><p>private:같은 클래스 내에서만 접근이 가능하다.</p></li>
            <li><p>접근 제어자를 사용하는 이유는 외부로부터 데이터를 보호하기 위함과 외부에는 필요하지않은 <br>내부적으로 작용하는 부분을 감추고 복잡성을 줄이기 위해서이다.</p></li>
          </ul>
            <li><h3>이 외 제어자(CONTINUE)</h3></li>
          </ol>
          <li><h2>다형성</h2></li>
          <ol>
            <li><h3>다형성</h3></li>
          <ul>
            <li><p>다형성이란 여러가지 형태를 가질 수 있는 능력을 의미하며 한 타입의 참조변수로 여러 객체를 참조할 수 있다.</p></li>
            <li><p>부모 타입의 참조변수는 자손클래스의 인스턴스를 참조할 수 있다.</p></li>
            <li><p>자손 타입의 참조변수는 부모클래스의 인스턴스를 참조할 수 없다.</p></li>
            <li><p>자손 클래스의 인스턴스를 참조하여 멤버들의 호출을 제한해 복잡성을 줄일 수도 있다.</p></li>
              </ul>
            <li><h3>참조변수의 형변환</h3></li>
            <ul>
              <li><p>참조변수는 상속관계에 있는 클래스사이에 형변환만 가능하다.</p></li>
              <li><p>자손타입->부모타입(UP-casting)</p></li>
              <li><p>부모타입->자손타입(DWON-casting)</p></li>
              <li><p>참조변수가 가르키는 인스턴스의 자손타입으로 형변환은 가능하지않다</p></li>
              <li><p> A instanceof B: A라는 참조변수가 B타입으로 형변환이 가능하면 TRUE 그렇지 않으면 FALSE를 반환한다.</p></li>
            </ul>
            <pre class ="prettyprint"><code>
 class root{
	 void root_print() {
		 System.out.println("root");
	 }
 }
 class parent extends root{
	 void parent_print() {
		 System.out.println("parent");
	 }
 }
 class child extends parent{
	 void child_print() {
		 System.out.println("child");
	 }
 }
 public class Main {

	 public static void main(String[] args) {

		 child child_ref = new child();
		 //참조할 수 있는 멤버
		 child_ref.root_print();
		 child_ref.parent_print();
		 child_ref.child_print();

		 parent pt = child_ref;//조상타입의 참조변수가 자손인스턴스를 참조
		 //참조할 수 있는 멤버
		 pt.root_print();
		 pt.parent_print();

		 root rt = child_ref;//조상타입의 참조변수가 자손인스턴스를 참조
		 //참조할 수 있는 멤버
		 rt.root_print();

		 //==> 하나의 인스턴스에 다른타입의 참조변수들이 참조중!

		 parent parent_ref = new parent();

		 //child ct = (child)parent_ref; ->에러! 자손타입의 참조변수는 조상인스턴스를 참조할 수 없음.
		 child ct =null;
		 if(ct instanceof parent) {
			 ct = (child)parent_ref;
			 System.out.println("True");

		 }
                /*실행결과
                root
                parent
                child
                root
                parent
                root
                */
	 }
 }
            </code></pre>
          <li><h3>참조변수와 인스턴스</h3></li>
          <ul><li><p>인스턴스 메서드가 오버라이딩된 경우 참조변수의 타입에 관계없이 해당 인스턴스의 오버라이딩된 메서드가 호출된다.</li></p>
            <li><p>인스턴스 변수가 오버라이딩된 경우 참조변수의 타입에 따라 달라진다.</li></p>
          </ul>
          <pre class ="prettyprint"><code>
 class root{
	int x=30;
	 void print() {
		 System.out.println("root");
	 }
 }
 class parent extends root{
	 int x=20;
	 void print() {
		 System.out.println("parent");
	 }
 }
 class child extends parent{
	 int x=10;
	 void print() {
		 System.out.println("child");
	 }
 }
 public class Main {

	 public static void main(String[] args) {

		 child p1 = new child();
		 parent p2 = p1;
		 root p3 = p1;
		 //오버라이딩된 인스턴스 메서드
		 p1.print();//child
		 p2.print();//child
		 p3.print();//child

		 //인스턴스 변수
		 System.out.println(p1.x);//10
		 System.out.println(p2.x);//20
		 System.out.println(p3.x);//30
	 }
 }


          </code></pre>
            <li><h3>매개변수의 다형성</h3></li>
            <ul><li>참조변수의 다형적인 특징은 매개변수에서도 적용된다.</li>
            </ul>
            <pre class ="prettyprint"><code>
 class Product{
	 int price;
	 Product(int price){
		 this.price=price;
	 }
 }
 class Tv extends Product{
	 Tv(int price){
		 super(price);
	 }
 }
 class Computer extends Product{
	 Computer(int price){
		 super(price);
	 }
 }
 class Audio extends Product{
	 Audio(int price){
		 super(price);
	 }
 }
 class Buyer{
	 int has_money;
	 Buyer(int money){
		 has_money=money;
	 }
	 void buy(Product ref) {
		 if(has_money>=ref.price) {
			 has_money-=ref.price;
			 System.out.println("구입성공");
		 }
		 else {
			 System.out.println("돈이 부족합니다");
		 }
	 }
	 void state() {
		 System.out.println("현재 가지고 있는 돈: "+has_money);
	 }
 }

  public class Main {

	  public static void main(String[] args) {
		  Audio item1 = new Audio(20);
		  Computer item2 = new Computer(100);
		  Tv item3 = new Tv(150);

		  Buyer b = new Buyer(260);

                 b.buy(item2);
		 b.state();
		 //구입성공
		 //현재 가지고 있는 돈: 160
		 b.buy(item3);
		 b.state();
		 //구입성공
		 //현재 가지고 있는 돈: 10
		 b.buy(item1);
		 b.state();
		 //돈이 부족합니다
		 //현재 가지고 있는 돈: 10
	  }
 }

            </code></pre>
            <li><h3>여러 종류의 객체를 배열로 다루기.</h3></li>
            <ul>
              <li>부모타입의 참조변수로 자손타입의 객체를 참조하는 것이 가능하므로 <br>부모타입의 참조변수 배열을 사용해서 서로 다른 종류의 객체를 다룰 수 있다.</li>
            </ul>
            <pre class ="prettyprint"><code>
   class Product{
	 int price;
	 Product(int price){
		 this.price=price;
	 }
	 void print() {}
 }
 class Tv extends Product{
	 Tv(int price){
		 super(price);
	 }
	 void print() {
		 System.out.print("TV ");
	 }
 }
 class Computer extends Product{
	 Computer(int price){
		 super(price);
	 }
	 void print() {
		 System.out.print("Computer ");
	 }
 }
 class Audio extends Product{
	 Audio(int price){
		 super(price);
	 }
	 void print() {
		 System.out.print("Audio ");
	 }
 }
 class Buyer{
	 int has_money;
	 int has_count=0;
	 Product p[] = new Product[10];
	 Buyer(int money){
		 has_money=money;
	 }
	 void buy(Product ref) {
		 ref.print();
		 if(has_money>=ref.price) {
			 has_money-=ref.price;
			 //ref가 가르키는 인스턴스는 다르지만 부모타입의 참조변수 배열로 다룰 수 있다.
			 p[has_count++]=ref;
			 System.out.println("구입성공");
		 }
		 else {
			 System.out.println("돈이 부족합니다");
		 }
	 }
	 void state() {
		 System.out.println("현재 가지고 있는 돈: "+has_money);
	 }
 }

  public class Main {

	  public static void main(String[] args) {
		  Audio item1 = new Audio(20);
		  Computer item2 = new Computer(100);
		  Tv item3 = new Tv(150);

		  Buyer b = new Buyer(260);
		  b.buy(item2);
		  b.buy(item3);
		  b.buy(item1);
		  System.out.print("구매목록:");
		  for(int i=0;i<<span>b.has_count;i++) {
			  b.p[i].print();
		  }
            /* 출력결과
            Computer 구입성공
            TV 구입성공
            Audio 돈이 부족합니다
            구매목록:Computer TV
            */

	  }
  }

            </code></pre>
            <h2><li>추상클래스</li></h2>
            <ul>
            <p><li>미완성 메서드(추상 메서드)를 포함하고 있는 클래스 </li></p>
            <p><li>메서드나 클래스에 abstract키워드를 사용해주면 된다. </li><p>
            <p><li>인스턴스를 생성할 수 없으며 상속을 통해 자손클래스에 의해 완성될 수 있다.</li></p>
            <li><h3>추상 메서드</h3><ll>
              <ul>
                <p><li>메서드의 선언부만 작성하고 구현부는 작성하지 않는다.</li></p>
                <p><li>abstract키워드를 사용함으로써 자손클래스에서 구현을 강제한다.</li></p>
                <p><li>상속받은 추상메서드를 구현하지않는다면 추상클래스로 지정해주어야한다.</li></p>
              </ul>
              <pre class ="prettyprint"><code>
//추상메서드를 포함하고 있는 추상클래스 Product
 abstract class Product{
   abstract public void print();//추상메서드선언
 }
 class Computer extends Product{
   public void print() {
     System.out.println("Computer");//상속받은 추상메서드를 구현
   }
 }
 class Notebook extends Product{
   public void print() {
     System.out.println("Notebook");//상속받은 추상메서드를 구현
   }
 }
 class Phone extends Product{
   public void print() {
     System.out.println("Phone");//상속받은 추상메서드를 구현
   }
 }
  public class Main {

    public static void main(String[] args) {
     // Product p = new Product();추상클래스는 인스턴스를 생성할 수 없음.
     Product p[] = new Product[3];
     p[0] = new Computer();
     p[1] = new Notebook();
     p[2] = new Phone();
     for(int i=0;i<<span>3;i++) {
         p[i].print();
     }
     /*출력결과
     Computer
     Notebook
     Phone
     */
    }
  }
              </code></pre>
        </ul>
          </ol>
             </ul>
             </div>
           </div>
         <div class ="bound">
         </div>
       </div>
       <div class ="right">
         </div>
       </div>
       </body>
     </html>
